import { GIModel } from '../GIModel';
import {  TColor, TNormal, TTexture, EAttribNames, Txyz, EEntType, TId, TEntTypeIdx } from '../common';

const NOGROUPS = '---nogroups---';

/**
 * Import obj
 */
export function importObj(model: GIModel, obj_str: string): GIModel {
    enum EObjLine {
        OBJ_COMMENT = '#',
        OBJ_COORD = 'v ',
        OBJ_TEXTURE = 'vt ',
        OBJ_NORMAL = 'vn ',
        OBJ_FACE = 'f ',
        OBJ_LINE = 'l '
    }
    const obj_lines: string[] = obj_str.split(/\r?\n/);
    const coords: Txyz[] = [];
    const normals: TNormal[] = [];
    const textures: TTexture[] = [];
    const faces: number[][][] = [];
    const plines: number[][] = [];
    for (const obj_line of obj_lines) {
        if (obj_line.startsWith( EObjLine.OBJ_COMMENT )) {
            // Do not do anything
        } else if (obj_line.startsWith( EObjLine.OBJ_COORD )) {
            const coord: Txyz = obj_line.split(' ').slice(1, 4).map( v => parseFloat(v) ) as Txyz;
            coords.push(coord);
        } else if (obj_line.startsWith( EObjLine.OBJ_TEXTURE )) {
            const normal: TNormal = obj_line.split(' ').slice(1, 4).map( v => parseFloat(v) ) as TNormal;
            normals.push(normal);
        } else if (obj_line.startsWith( EObjLine.OBJ_NORMAL )) {
            const texture: TTexture = obj_line.split(' ').slice(1, 3).map( v => parseFloat(v) ) as TTexture;
            textures.push(texture);
        } else if (obj_line.startsWith( EObjLine.OBJ_FACE )) {
            const face_strs: string[] = obj_line.split(' ').slice(1);
            const v_indexes: number[] = [];
            const t_indexes: number[] = [];
            const n_indexes: number[] = [];
            face_strs.forEach( face_str => {
                const face_sub_indexes: number[] = face_str.split('/').map( str => parseInt(str, 10) - 1 );
                v_indexes.push(face_sub_indexes[0]);
                t_indexes.push(face_sub_indexes[1]);
                n_indexes.push(face_sub_indexes[2]);
            });
            faces.push([v_indexes, t_indexes, n_indexes]);
        } else if (obj_line.startsWith( EObjLine.OBJ_LINE )) {
            const pline: number[] = obj_line.split(' ').slice(1).map( v => parseInt(v, 10) - 1 ) as TTexture;
            plines.push(pline);
        } else {
            console.log('Found unrecognised line of data in OBJ file');
        }
    }
    for (const coord of coords) {
        const posi_i: number = model.modeldata.geom.add.addPosi();
        model.modeldata.attribs.set.setEntAttribVal(EEntType.POSI, posi_i, EAttribNames.COORDS, coord);
    }
    for (const face of faces) {
        const face_i: number = model.modeldata.geom.add.addPgon(face[0]);
        // TODO: texture uv
        // TODO: normals
    }
    return model;
}

/**
 * Export to obj
 */
export function exportVertBasedObj(model: GIModel, entities: TEntTypeIdx[]): string {
    const h_str = '# File generated by Mobius.\n';
    // the order of data is 1) vertex, 2) texture, 3) normal
    let v_str = '';
    let f_str = '';
    let l_str = '';
    // do we have color, texture, normal?
    const has_color_attrib: boolean = model.modeldata.attribs.query.hasEntAttrib(EEntType.VERT, EAttribNames.COLOR);
    const has_normal_attrib: boolean = model.modeldata.attribs.query.hasEntAttrib(EEntType.VERT, EAttribNames.NORMAL);
    const has_texture_attrib: boolean = model.modeldata.attribs.query.hasEntAttrib(EEntType.VERT, EAttribNames.TEXTURE);
    // get the polgons, polylines, verts, posis
    const [pgons_i, plines_i]: [number[], number[]] = _getPgonsPlines(model, entities);
    const [verts_i, posis_i]: [number[], number[]] = _getVertsPosis(model, pgons_i, plines_i);
    // vertices, v
    const vert_i_to_obj_v: number[] = [];
    let num_v = 0;
    for (let i = 0; i < verts_i.length; i++) {
        const vert_i: number =  verts_i[i];
        const coord: Txyz = model.modeldata.attribs.posis.getVertCoords(vert_i);
        if (has_color_attrib) {
            let color: TColor = model.modeldata.attribs.get.getEntAttribVal(EEntType.VERT, vert_i, EAttribNames.COLOR) as TColor;
            if (color === undefined) { color = [1, 1, 1]; }
            v_str += 'v ' + coord.map( v => v.toString() ).join(' ')  + ' ' + color.map( c => c.toString() ).join(' ') + '\n';
        } else {
            v_str += 'v ' + coord.map( v => v.toString() ).join(' ') + '\n';
        }
        vert_i_to_obj_v[vert_i] = i;
        num_v += 1;
    }
   // textures, vt
   const [num_vt, vert_i_obj_vt, vt_str]: [number, number[], string] = _getTexturesStr(model, verts_i, has_texture_attrib);
   // normals, vn
   const [num_vn, vert_i_obj_vn, vn_str]: [number, number[], string] = _getNormalsStr(model, verts_i, has_normal_attrib);
   // polygons, f
   const [keys_pgons, map_colls_to_pgons]: [string[], Map<string, [string[], number[]]>] =
       _getGroups(model, EEntType.PGON, pgons_i);
    // polygons, f
    for (const key of keys_pgons) {
        const [names, group_pgons_i]: [string[], number[]] = map_colls_to_pgons.get(key);
        if (key !== NOGROUPS) {
            f_str += 'g ' + names.join( ' ' ) + '\n';
        }
        for (const pgon_i of group_pgons_i) {
            const pgon_verts_i_outer: number[] = model.modeldata.geom.nav.navAnyToVert(EEntType.PGON, pgon_i);
            // const verts_i_outer = verts_i[0];
            // TODO what about holes
            f_str += 'f ';
            for (const vert_i of pgon_verts_i_outer) {
                // v
                f_str += (1 + vert_i_to_obj_v[vert_i]);
                if (has_texture_attrib || has_normal_attrib) {
                    // vt
                    if (has_texture_attrib) {
                        // TODO ignore them for now
                        f_str += '/';
                    } else {
                        f_str += '/';
                    }
                    // vn
                    if (has_normal_attrib) {
                        f_str += '/' + (1 + num_v + num_vt + vert_i_obj_vn[vert_i]);
                    } else {
                        f_str += '/';
                    }
                }
                f_str += ' ';
            }
            f_str += '\n';
        }
    }
    // polylines, l
    const [keys_plines, map_colls_to_plines]: [string[], Map<string, [string[], number[]]>] =
        _getGroups(model, EEntType.PLINE, plines_i);
    // process all the groups
    for (const key of keys_plines) {
        const [names, group_plines_i]: [string[], number[]] = map_colls_to_plines.get(key);
        if (key !== NOGROUPS) {
            f_str += 'g ' + names.join( ' ' ) + '\n';
        }
        for (const pline_i of group_plines_i) {
            const pline_verts_i: number[] = model.modeldata.geom.nav.navAnyToVert(EEntType.PLINE, pline_i);
            l_str += 'l ' + pline_verts_i.map( vert_i => (vert_i_to_obj_v[vert_i] + 1).toString() ).join(' ') + '\n';
        }
    }
    // result
    return h_str + v_str + vt_str + vn_str + f_str + l_str;
}

/**
 * Export to obj
 */
export function exportPosiBasedObj(model: GIModel, entities: TEntTypeIdx[]): string {
    const h_str = '# File generated by Mobius.\n';
    // the order of data is 1) vertex, 2) texture, 3) normal
    let v_str = '';
    let f_str = '';
    let l_str = '';
    // do we have color, texture, normal?
    const has_color_attrib: boolean = model.modeldata.attribs.query.hasEntAttrib(EEntType.VERT, EAttribNames.COLOR);
    const has_normal_attrib: boolean = model.modeldata.attribs.query.hasEntAttrib(EEntType.VERT, EAttribNames.NORMAL);
    const has_texture_attrib: boolean = model.modeldata.attribs.query.hasEntAttrib(EEntType.VERT, EAttribNames.TEXTURE);
    // get the polgons, polylines, verts, posis
    const [pgons_i, plines_i]: [number[], number[]] = _getPgonsPlines(model, entities);
    const [verts_i, posis_i]: [number[], number[]] = _getVertsPosis(model, pgons_i, plines_i);
    // positions
    let num_v = 0;
    const posi_i_to_obj_v: number[] = [];
    for (let i = 0; i < posis_i.length; i++) {
        const posi_i: number =  posis_i[i];
        const coord: Txyz = model.modeldata.attribs.posis.getPosiCoords(posi_i);
        if (has_color_attrib) {
            // get the average color from the verts
            const posi_verts_i: number[] = model.modeldata.geom.nav.navPosiToVert(posi_i);
            let color: TColor = [0, 0, 0];
            for (const posi_vert_i of posi_verts_i) {
                let vert_color: TColor =
                    model.modeldata.attribs.get.getEntAttribVal(EEntType.VERT, posi_vert_i, EAttribNames.COLOR) as TColor;
                if (vert_color === undefined) { vert_color = [1, 1, 1]; }
                color = [color[0] + vert_color[0], color[1] + vert_color[1], color[2] + vert_color[2]];
            }
            const div: number = posi_verts_i.length;
            color = [color[0] / div, color[1] / div, color[2] / div];
            v_str += 'v ' + coord.map( v => v.toString() ).join(' ')  + ' ' + color.map( c => c.toString() ).join(' ') + '\n';
        } else {
            v_str += 'v ' + coord.map( v => v.toString() ).join(' ') + '\n';
        }
        posi_i_to_obj_v[posi_i] = i;
        num_v += 1;
    }
    // textures, vt
    const [num_vt, vert_i_obj_vt, vt_str]: [number, number[], string] = _getTexturesStr(model, verts_i, has_texture_attrib);
    // normals, vn
    const [num_vn, vert_i_obj_vn, vn_str]: [number, number[], string] = _getNormalsStr(model, verts_i, has_normal_attrib);
    // polygons, f
    const [keys_pgons, map_colls_to_pgons]: [string[], Map<string, [string[], number[]]>] =
        _getGroups(model, EEntType.PGON, pgons_i);
    // process all the groups
    for (const key of keys_pgons) {
        const [names, group_pgons_i]: [string[], number[]] = map_colls_to_pgons.get(key);
        if (key !== NOGROUPS) {
            f_str += 'g ' + names.join( ' ' ) + '\n';
        }
        for (const pgon_i of group_pgons_i) {
            const pgon_verts_i_outer: number[] = model.modeldata.geom.nav.navAnyToVert(EEntType.PGON, pgon_i);
            // const verts_i_outer = verts_i[0];
            // TODO what about holes
            f_str += 'f ';
            for (const vert_i of pgon_verts_i_outer) {
                // v
                f_str += (1 + posi_i_to_obj_v[model.modeldata.geom.nav.navVertToPosi(vert_i)]);
                if (has_texture_attrib || has_normal_attrib) {
                    // vt
                    if (has_texture_attrib && vert_i_obj_vt[vert_i] !== undefined) {
                        // TODO ignore them for now
                        f_str += '/';
                    } else {
                        f_str += '/';
                    }
                    // vn
                    if (has_normal_attrib && vert_i_obj_vn[vert_i] !== undefined) {
                        f_str += '/' + (1 + num_v + num_vt + vert_i_obj_vn[vert_i]);
                    } else {
                        f_str += '/';
                    }
                }
                f_str += ' ';
            }
            f_str += '\n';
        }
    }
    // polylines, l
    const [keys_plines, map_colls_to_plines]: [string[], Map<string, [string[], number[]]>] =
        _getGroups(model, EEntType.PLINE, plines_i);
    // process all the groups
    for (const key of keys_plines) {
        const [names, group_plines_i]: [string[], number[]] = map_colls_to_plines.get(key);
        if (key !== NOGROUPS) {
            f_str += 'g ' + names.join( ' ' ) + '\n';
        }
        for (const pline_i of group_plines_i) {
            const pline_verts_i: number[] = model.modeldata.geom.nav.navAnyToVert(EEntType.PLINE, pline_i);
            l_str += 'l ' + pline_verts_i.map( vert_i =>
                (posi_i_to_obj_v[model.modeldata.geom.nav.navVertToPosi(vert_i)] + 1).toString() ).join(' ') + '\n';
        }
    }
    // result
    return h_str + v_str + vt_str + vn_str + f_str + l_str;
}

/**
 * Get the textures
 */
function _getTexturesStr(model: GIModel, verts_i: number[], has_texture_attrib: boolean): [number, number[], string] {
    let vt_str = '';
    // textures, vt
    let num_vt = 0;
    const vert_i_obj_vt: number[] = []; // sparse array
    if (has_texture_attrib) {
        for (let i = 0; i < verts_i.length; i++) {
            const vert_i  = verts_i[i];
            const texture: TTexture = model.modeldata.attribs.get.getEntAttribVal(EEntType.VERT, vert_i, EAttribNames.TEXTURE) as TTexture;
            if (texture !== undefined) {
                vt_str += 'vt ' + texture.map( v => v.toString() ).join(' ') + '\n';
                vert_i_obj_vt[vert_i] = i;
                num_vt += 1;
            }
        }
    }
    return [num_vt, vert_i_obj_vt, vt_str];
}
/**
 * Get the normals
 */
function _getNormalsStr(model: GIModel, verts_i: number[], has_normal_attrib: boolean): [number, number[], string] {
    let vn_str = '';
    // normals, vn
    let num_vn = 0;
    const vert_i_obj_vn: number[] = []; // sparse array
    if (has_normal_attrib) {
        for (let i = 0; i < verts_i.length; i++) {
            const vert_i  = verts_i[i];
            const  normal: TNormal = model.modeldata.attribs.get.getEntAttribVal(EEntType.VERT, vert_i, EAttribNames.NORMAL) as TNormal;
            if (normal !== undefined) {
                vn_str += 'vn ' + normal.map( v => v.toString() ).join(' ') + '\n';
                vert_i_obj_vn[vert_i] = i;
                num_vn += 1;
            }
        }
    }
    return [num_vn, vert_i_obj_vn, vn_str];
}

/**
 * Get the groups
 */
function _getGroups(model: GIModel, ent_type: EEntType, ents_i: number[]): [string[], Map<string, [string[], number[]]>] {
    const map_colls_to_ents: Map<string, [string[], number[]]> = new Map();
    // check if the name attribut exists
    if (!model.modeldata.attribs.query.hasEntAttrib(EEntType.COLL, 'name')) {
        return [[NOGROUPS], map_colls_to_ents.set(NOGROUPS, [[], ents_i])];
    }
    // get the collections of each entity
    for (const ent_i of ents_i) {
        const colls_i: number[] = model.modeldata.geom.nav.navAnyToColl(ent_type, ent_i);
        const set_all_colls_i: Set<number> = new Set();
        for (const coll_i of colls_i) {
            set_all_colls_i.add(coll_i);
            for (const anc_coll_i of model.modeldata.geom.modeldata.geom.colls.getCollAncestors(coll_i)) {
                set_all_colls_i.add(anc_coll_i);
            }
        }
        const names: string[] = model.modeldata.attribs.get.getEntAttribVal(EEntType.COLL, Array.from(set_all_colls_i), 'name') as string[];
        let key = NOGROUPS;
        if (names.length > 0) {
            names.sort();
            key = names.join('-');
        }
        if (!map_colls_to_ents.has(key)) {
            map_colls_to_ents.set(key, [names, []]);
        }
        map_colls_to_ents.get(key)[1].push(ent_i);
    }
    // make sure the ---nogroups--- key is first in the list
    let keys: string[] = Array.from(map_colls_to_ents.keys());
    const ng_i: number = keys.indexOf(NOGROUPS);
    if (ng_i !== -1) {
        keys = keys.splice(ng_i, 1).splice(0, 0, NOGROUPS);
    }
    // return the keys arrays, and the map
    return [keys, map_colls_to_ents];
}


/**
 * Get all the polygons and polyline entities.
 */
function _getPgonsPlines(model: GIModel, entities: TEntTypeIdx[]): [number[], number[]] {
    let pgons_i: number[] = [];
    let plines_i: number[] = [];
    if (entities === null) {
        pgons_i = model.modeldata.geom.query.getEnts(EEntType.PGON);
        plines_i = model.modeldata.geom.query.getEnts(EEntType.PLINE);
    } else {
        for (const [ent_type, ent_i] of entities) {
            if (ent_type === EEntType.PGON) {
                pgons_i.push(ent_i);
            } else if (ent_type === EEntType.PLINE) {
                plines_i.push(ent_i);
            } else if (ent_type === EEntType.COLL) {
                for (const pgon_i of model.modeldata.geom.nav.navAnyToPgon(EEntType.COLL, ent_i)) {
                    pgons_i.push(pgon_i);
                }
                for (const pline_i of model.modeldata.geom.nav.navAnyToPline(EEntType.COLL, ent_i)) {
                    plines_i.push(pline_i);
                }
            }
        }
    }
    return [pgons_i, plines_i];
}

/**
 * Get all the posis from the polygon and polyline entities.
 */
function _getVertsPosis(model: GIModel, pgons_i: number[], plines_i: number[]): [number[], number[]] {
    const posis_i: Set<number> = new Set();
    const verts_i: Set<number> = new Set();
    for (const pgon_i of pgons_i) {
        for (const vert_i of model.modeldata.geom.nav.navAnyToVert(EEntType.PGON, pgon_i)) {
            verts_i.add(vert_i);
        }
        for (const posi_i of model.modeldata.geom.nav.navAnyToPosi(EEntType.PGON, pgon_i)) {
            posis_i.add(posi_i);
        }
    }
    for (const pline_i of plines_i) {
        for (const vert_i of model.modeldata.geom.nav.navAnyToVert(EEntType.PLINE, pline_i)) {
            verts_i.add(vert_i);
        }
        for (const posi_i of model.modeldata.geom.nav.navAnyToPosi(EEntType.PLINE, pline_i)) {
            posis_i.add(posi_i);
        }
    }
    return [Array.from(verts_i), Array.from(posis_i)];
}
